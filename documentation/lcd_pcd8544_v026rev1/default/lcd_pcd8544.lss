
lcd_pcd8544.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         00000c92  00000000  00000000  00000074  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .bss          000001ff  00800060  00800060  00000d06  2**0
                  ALLOC
  2 .debug_aranges 00000040  00000000  00000000  00000d06  2**0
                  CONTENTS, READONLY, DEBUGGING
  3 .debug_pubnames 000000e7  00000000  00000000  00000d46  2**0
                  CONTENTS, READONLY, DEBUGGING
  4 .debug_info   00000b5c  00000000  00000000  00000e2d  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .debug_abbrev 000003a3  00000000  00000000  00001989  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_line   00000a14  00000000  00000000  00001d2c  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_frame  00000110  00000000  00000000  00002740  2**2
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_str    00000317  00000000  00000000  00002850  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_loc    0000090e  00000000  00000000  00002b67  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_ranges 00000030  00000000  00000000  00003475  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
   0:	f9 c1       	rjmp	.+1010   	; 0x3f4 <__ctors_end>
   2:	13 c2       	rjmp	.+1062   	; 0x42a <__bad_interrupt>
   4:	12 c2       	rjmp	.+1060   	; 0x42a <__bad_interrupt>
   6:	11 c2       	rjmp	.+1058   	; 0x42a <__bad_interrupt>
   8:	10 c2       	rjmp	.+1056   	; 0x42a <__bad_interrupt>
   a:	0f c2       	rjmp	.+1054   	; 0x42a <__bad_interrupt>
   c:	0e c2       	rjmp	.+1052   	; 0x42a <__bad_interrupt>
   e:	0d c2       	rjmp	.+1050   	; 0x42a <__bad_interrupt>
  10:	0c c2       	rjmp	.+1048   	; 0x42a <__bad_interrupt>
  12:	0b c2       	rjmp	.+1046   	; 0x42a <__bad_interrupt>
  14:	0a c2       	rjmp	.+1044   	; 0x42a <__bad_interrupt>
  16:	09 c2       	rjmp	.+1042   	; 0x42a <__bad_interrupt>
  18:	08 c2       	rjmp	.+1040   	; 0x42a <__bad_interrupt>
  1a:	07 c2       	rjmp	.+1038   	; 0x42a <__bad_interrupt>
  1c:	06 c2       	rjmp	.+1036   	; 0x42a <__bad_interrupt>
  1e:	05 c2       	rjmp	.+1034   	; 0x42a <__bad_interrupt>
  20:	04 c2       	rjmp	.+1032   	; 0x42a <__bad_interrupt>
  22:	03 c2       	rjmp	.+1030   	; 0x42a <__bad_interrupt>
  24:	02 c2       	rjmp	.+1028   	; 0x42a <__bad_interrupt>

00000026 <waitImage>:
	...
  82:	00 c0 20 20 20 20 20 20 20 20 20 20 c0 00 00 00     ..          ....
  92:	00 00 00 00 00 00 f0 10 10 10 10 e0 00 00 f0 00     ................
  a2:	00 80 40 40 40 80 00 00 80 40 40 40 80 00 00 80     ..@@@....@@@....
  b2:	40 40 40 80 00 00 80 40 40 40 80 00 00 00 00 00     @@@....@@@......
	...
  d6:	00 0f 11 31 31 d1 f1 d1 d1 31 11 11 0f 00 00 00     ...11....1......
  e6:	00 00 00 00 00 00 1f 01 01 01 01 00 00 00 1f 00     ................
  f6:	00 0f 12 12 12 0b 00 00 0c 12 12 0a 1f 00 00 09     ................
 106:	12 12 12 0c 00 00 0f 12 12 12 0b 00 00 00 00 00     ................
	...
 12a:	00 f0 18 86 86 e1 f1 e1 e1 86 18 18 f0 00 00 00     ................
	...
 142:	60 80 00 80 60 80 00 80 60 00 40 20 20 20 c0 00     `...`...`.@   ..
 152:	00 e8 00 20 f8 20 00 00 00 00 00 00 00 00 00 00     ... . ..........
	...
 17e:	00 03 07 07 07 07 07 07 07 07 07 07 03 00 00 00     ................
	...
 196:	00 03 0c 03 00 03 0c 03 00 00 06 09 09 05 0f 00     ................
 1a6:	00 0f 00 00 0f 08 00 00 00 00 08 00 00 08 00 00     ................
 1b6:	08 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
	...

0000021e <__c.1413>:
 21e:	47 6f 74 6f 20 54 65 73 74 00                       Goto Test.

00000228 <__c.1411>:
 228:	54 65 73 74 00                                      Test.

0000022d <FontLookup>:
 22d:	00 00 00 00 00 00 00 2f 00 00 00 07 00 07 00 14     ......./........
 23d:	7f 14 7f 14 24 2a 7f 2a 12 c4 c8 10 26 46 36 49     ....$*.*....&F6I
 24d:	55 22 50 00 05 03 00 00 00 1c 22 41 00 00 41 22     U"P......."A..A"
 25d:	1c 00 14 08 3e 08 14 08 08 3e 08 08 00 00 50 30     ....>....>....P0
 26d:	00 10 10 10 10 10 00 60 60 00 00 20 10 08 04 02     .......``.. ....
 27d:	3e 51 49 45 3e 00 42 7f 40 00 42 61 51 49 46 21     >QIE>.B.@.BaQIF!
 28d:	41 45 4b 31 18 14 12 7f 10 27 45 45 45 39 3c 4a     AEK1.....'EEE9<J
 29d:	49 49 30 01 71 09 05 03 36 49 49 49 36 06 49 49     II0.q...6III6.II
 2ad:	29 1e 00 36 36 00 00 00 56 36 00 00 08 14 22 41     )..66...V6...."A
 2bd:	00 14 14 14 14 14 00 41 22 14 08 02 01 51 09 06     .......A"....Q..
 2cd:	32 49 59 51 3e 7e 11 11 11 7e 7f 49 49 49 36 3e     2IYQ>~...~.III6>
 2dd:	41 41 41 22 7f 41 41 22 1c 7f 49 49 49 41 7f 09     AAA".AA"..IIIA..
 2ed:	09 09 01 3e 41 49 49 7a 7f 08 08 08 7f 00 41 7f     ...>AIIz......A.
 2fd:	41 00 20 40 41 3f 01 7f 08 14 22 41 7f 40 40 40     A. @A?...."A.@@@
 30d:	40 7f 02 0c 02 7f 7f 04 08 10 7f 3e 41 41 41 3e     @..........>AAA>
 31d:	7f 09 09 09 06 3e 41 51 21 5e 7f 09 19 29 46 46     .....>AQ!^...)FF
 32d:	49 49 49 31 01 01 7f 01 01 3f 40 40 40 3f 1f 20     III1.....?@@@?. 
 33d:	40 20 1f 3f 40 38 40 3f 63 14 08 14 63 07 08 70     @ .?@8@?c...c..p
 34d:	08 07 61 51 49 45 43 00 7f 41 41 00 55 2a 55 2a     ..aQIEC..AA.U*U*
 35d:	55 00 41 41 7f 00 04 02 01 02 04 40 40 40 40 40     U.AA.......@@@@@
 36d:	00 01 02 04 00 20 54 54 54 78 7f 48 44 44 38 38     ..... TTTx.HDD88
 37d:	44 44 44 20 38 44 44 48 7f 38 54 54 54 18 08 7e     DDD 8DDH.8TTT..~
 38d:	09 01 02 0c 52 52 52 3e 7f 08 04 04 78 00 44 7d     ....RRR>....x.D}
 39d:	40 00 20 40 44 3d 00 7f 10 28 44 00 00 41 7f 40     @. @D=...(D..A.@
 3ad:	00 7c 04 18 04 78 7c 08 04 04 78 38 44 44 44 38     .|...x|...x8DDD8
 3bd:	7c 14 14 14 08 08 14 14 18 7c 7c 08 04 04 08 48     |........||....H
 3cd:	54 54 54 20 04 3f 44 40 20 3c 40 40 20 7c 1c 20     TTT .?D@ <@@ |. 
 3dd:	40 20 1c 3c 40 30 40 3c 44 28 10 28 44 0c 50 50     @ .<@0@<D(.(D.PP
 3ed:	50 3c 44 64 54 4c 44                                P<DdTLD

000003f4 <__ctors_end>:
 3f4:	11 24       	eor	r1, r1
 3f6:	1f be       	out	0x3f, r1	; 63
 3f8:	cf e5       	ldi	r28, 0x5F	; 95
 3fa:	d4 e0       	ldi	r29, 0x04	; 4
 3fc:	de bf       	out	0x3e, r29	; 62
 3fe:	cd bf       	out	0x3d, r28	; 61

00000400 <__do_copy_data>:
 400:	10 e0       	ldi	r17, 0x00	; 0
 402:	a0 e6       	ldi	r26, 0x60	; 96
 404:	b0 e0       	ldi	r27, 0x00	; 0
 406:	e2 e9       	ldi	r30, 0x92	; 146
 408:	fc e0       	ldi	r31, 0x0C	; 12
 40a:	02 c0       	rjmp	.+4      	; 0x410 <.do_copy_data_start>

0000040c <.do_copy_data_loop>:
 40c:	05 90       	lpm	r0, Z+
 40e:	0d 92       	st	X+, r0

00000410 <.do_copy_data_start>:
 410:	a0 36       	cpi	r26, 0x60	; 96
 412:	b1 07       	cpc	r27, r17
 414:	d9 f7       	brne	.-10     	; 0x40c <.do_copy_data_loop>

00000416 <__do_clear_bss>:
 416:	12 e0       	ldi	r17, 0x02	; 2
 418:	a0 e6       	ldi	r26, 0x60	; 96
 41a:	b0 e0       	ldi	r27, 0x00	; 0
 41c:	01 c0       	rjmp	.+2      	; 0x420 <.do_clear_bss_start>

0000041e <.do_clear_bss_loop>:
 41e:	1d 92       	st	X+, r1

00000420 <.do_clear_bss_start>:
 420:	af 35       	cpi	r26, 0x5F	; 95
 422:	b1 07       	cpc	r27, r17
 424:	e1 f7       	brne	.-8      	; 0x41e <.do_clear_bss_loop>
 426:	02 d0       	rcall	.+4      	; 0x42c <main>
 428:	32 c4       	rjmp	.+2148   	; 0xc8e <_exit>

0000042a <__bad_interrupt>:
 42a:	ea cd       	rjmp	.-1068   	; 0x0 <__vectors>

0000042c <main>:
#include "main.h"


int main()
{
    LcdInit();
 42c:	c0 d3       	rcall	.+1920   	; 0xbae <LcdInit>


    //display image
    LcdContrast(0x7F);
 42e:	8f e7       	ldi	r24, 0x7F	; 127
 430:	36 d0       	rcall	.+108    	; 0x49e <LcdContrast>
    LcdClear();
 432:	a5 d3       	rcall	.+1866   	; 0xb7e <LcdClear>
    LcdImage(waitImage); 
 434:	86 e2       	ldi	r24, 0x26	; 38
 436:	90 e0       	ldi	r25, 0x00	; 0
 438:	8e d3       	rcall	.+1820   	; 0xb56 <LcdImage>
    LcdUpdate();
 43a:	29 d3       	rcall	.+1618   	; 0xa8e <LcdUpdate>
 43c:	88 ea       	ldi	r24, 0xA8	; 168
 43e:	91 e6       	ldi	r25, 0x61	; 97
    milliseconds can be achieved.
 */
void
_delay_loop_2(uint16_t __count)
{
	__asm__ volatile (
 440:	24 e6       	ldi	r18, 0x64	; 100
 442:	30 e0       	ldi	r19, 0x00	; 0
 444:	f9 01       	movw	r30, r18
 446:	31 97       	sbiw	r30, 0x01	; 1
 448:	f1 f7       	brne	.-4      	; 0x446 <main+0x1a>
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
 44a:	01 97       	sbiw	r24, 0x01	; 1
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
 44c:	d9 f7       	brne	.-10     	; 0x444 <main+0x18>


    _delay_ms(2500);
    LcdContrast(0x00);
 44e:	80 e0       	ldi	r24, 0x00	; 0
 450:	26 d0       	rcall	.+76     	; 0x49e <LcdContrast>
    LcdUpdate();
 452:	1d d3       	rcall	.+1594   	; 0xa8e <LcdUpdate>
 454:	88 ea       	ldi	r24, 0xA8	; 168
 456:	91 e6       	ldi	r25, 0x61	; 97
 458:	24 e6       	ldi	r18, 0x64	; 100
 45a:	30 e0       	ldi	r19, 0x00	; 0
 45c:	f9 01       	movw	r30, r18
 45e:	31 97       	sbiw	r30, 0x01	; 1
 460:	f1 f7       	brne	.-4      	; 0x45e <main+0x32>
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
 462:	01 97       	sbiw	r24, 0x01	; 1
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
 464:	d9 f7       	brne	.-10     	; 0x45c <main+0x30>
    _delay_ms(2500);

    //display string
    LcdClear();
 466:	8b d3       	rcall	.+1814   	; 0xb7e <LcdClear>
    LcdGotoXYFont(1,1);
 468:	81 e0       	ldi	r24, 0x01	; 1
 46a:	61 e0       	ldi	r22, 0x01	; 1
 46c:	2f d0       	rcall	.+94     	; 0x4cc <LcdGotoXYFont>
    LcdFStr(FONT_1X,(unsigned char*)PSTR("Test"));
 46e:	81 e0       	ldi	r24, 0x01	; 1
 470:	68 e2       	ldi	r22, 0x28	; 40
 472:	72 e0       	ldi	r23, 0x02	; 2
 474:	62 d1       	rcall	.+708    	; 0x73a <LcdFStr>
    LcdGotoXYFont(1,2);
 476:	81 e0       	ldi	r24, 0x01	; 1
 478:	62 e0       	ldi	r22, 0x02	; 2
 47a:	28 d0       	rcall	.+80     	; 0x4cc <LcdGotoXYFont>
    LcdFStr(FONT_1X,(unsigned char*)PSTR("Goto Test"));
 47c:	81 e0       	ldi	r24, 0x01	; 1
 47e:	6e e1       	ldi	r22, 0x1E	; 30
 480:	72 e0       	ldi	r23, 0x02	; 2
 482:	5b d1       	rcall	.+694    	; 0x73a <LcdFStr>
    LcdUpdate();
 484:	04 d3       	rcall	.+1544   	; 0xa8e <LcdUpdate>
 486:	80 e5       	ldi	r24, 0x50	; 80
 488:	93 ec       	ldi	r25, 0xC3	; 195
 48a:	24 e6       	ldi	r18, 0x64	; 100
 48c:	30 e0       	ldi	r19, 0x00	; 0
 48e:	f9 01       	movw	r30, r18
 490:	31 97       	sbiw	r30, 0x01	; 1
 492:	f1 f7       	brne	.-4      	; 0x490 <__stack+0x31>
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
 494:	01 97       	sbiw	r24, 0x01	; 1
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
 496:	d9 f7       	brne	.-10     	; 0x48e <__stack+0x2f>

    _delay_ms(5000);


    return 0;
}
 498:	80 e0       	ldi	r24, 0x00	; 0
 49a:	90 e0       	ldi	r25, 0x00	; 0
 49c:	08 95       	ret

0000049e <LcdContrast>:
 * Description  :  Set display contrast.
 * Argument(s)  :  contrast -> Contrast value from 0x00 to 0x7F.
 * Return value :  None.
 */
void LcdContrast ( byte contrast )
{
 49e:	98 2f       	mov	r25, r24
 * Return value :  None.
 */
static void LcdSend ( byte data, LcdCmdData cd )
{
    /*  Enable display controller (active low). */
    LCD_PORT &= ~( _BV( LCD_CE_PIN ) );
 4a0:	c2 98       	cbi	0x18, 2	; 24
    {
        LCD_PORT |= _BV( LCD_DC_PIN );
    }
    else
    {
        LCD_PORT &= ~( _BV( LCD_DC_PIN ) );
 4a2:	c0 98       	cbi	0x18, 0	; 24
    }

    /*  Send data to display controller. */
    SPDR = data;
 4a4:	81 e2       	ldi	r24, 0x21	; 33
 4a6:	8f b9       	out	0x0f, r24	; 15

    /*  Wait until Tx register empty. */
    while ( (SPSR & 0x80) != 0x80 );
 4a8:	77 9b       	sbis	0x0e, 7	; 14
 4aa:	fe cf       	rjmp	.-4      	; 0x4a8 <LcdContrast+0xa>


    /* Disable display controller. */
    LCD_PORT |= _BV( LCD_CE_PIN );
 4ac:	c2 9a       	sbi	0x18, 2	; 24
{
    /* LCD Extended Commands. */
    LcdSend( 0x21, LCD_CMD );

    /* Set LCD contrast level. */
    LcdSend( 0x80 | contrast, LCD_CMD );
 4ae:	90 68       	ori	r25, 0x80	; 128
 * Return value :  None.
 */
static void LcdSend ( byte data, LcdCmdData cd )
{
    /*  Enable display controller (active low). */
    LCD_PORT &= ~( _BV( LCD_CE_PIN ) );
 4b0:	c2 98       	cbi	0x18, 2	; 24
    {
        LCD_PORT |= _BV( LCD_DC_PIN );
    }
    else
    {
        LCD_PORT &= ~( _BV( LCD_DC_PIN ) );
 4b2:	c0 98       	cbi	0x18, 0	; 24
    }

    /*  Send data to display controller. */
    SPDR = data;
 4b4:	9f b9       	out	0x0f, r25	; 15

    /*  Wait until Tx register empty. */
    while ( (SPSR & 0x80) != 0x80 );
 4b6:	77 9b       	sbis	0x0e, 7	; 14
 4b8:	fe cf       	rjmp	.-4      	; 0x4b6 <LcdContrast+0x18>


    /* Disable display controller. */
    LCD_PORT |= _BV( LCD_CE_PIN );
 4ba:	c2 9a       	sbi	0x18, 2	; 24
 * Return value :  None.
 */
static void LcdSend ( byte data, LcdCmdData cd )
{
    /*  Enable display controller (active low). */
    LCD_PORT &= ~( _BV( LCD_CE_PIN ) );
 4bc:	c2 98       	cbi	0x18, 2	; 24
    {
        LCD_PORT |= _BV( LCD_DC_PIN );
    }
    else
    {
        LCD_PORT &= ~( _BV( LCD_DC_PIN ) );
 4be:	c0 98       	cbi	0x18, 0	; 24
    }

    /*  Send data to display controller. */
    SPDR = data;
 4c0:	80 e2       	ldi	r24, 0x20	; 32
 4c2:	8f b9       	out	0x0f, r24	; 15

    /*  Wait until Tx register empty. */
    while ( (SPSR & 0x80) != 0x80 );
 4c4:	77 9b       	sbis	0x0e, 7	; 14
 4c6:	fe cf       	rjmp	.-4      	; 0x4c4 <LcdContrast+0x26>


    /* Disable display controller. */
    LCD_PORT |= _BV( LCD_CE_PIN );
 4c8:	c2 9a       	sbi	0x18, 2	; 24
    /* Set LCD contrast level. */
    LcdSend( 0x80 | contrast, LCD_CMD );

    /* LCD Standard Commands, horizontal addressing mode. */
    LcdSend( 0x20, LCD_CMD );
}
 4ca:	08 95       	ret

000004cc <LcdGotoXYFont>:
 * Argument(s)  :  x, y -> Coordinate for new cursor position. Range: 1,1 .. 14,6
 * Return value :  see return value in pcd8544.h
 * Note         :  Based on Sylvain Bissonette's code
 */
byte LcdGotoXYFont ( byte x, byte y )
{
 4cc:	98 2f       	mov	r25, r24
    /* Boundary check, slow down the speed but will guarantee this code wont fail */
    /* Version 0.2.5 - Fixed on Dec 25, 2008 (XMAS) */
    if( x > 14)
 4ce:	8f 30       	cpi	r24, 0x0F	; 15
 4d0:	a0 f4       	brcc	.+40     	; 0x4fa <LcdGotoXYFont+0x2e>
        return OUT_OF_BORDER;
    if( y > 6)
 4d2:	67 30       	cpi	r22, 0x07	; 7
 4d4:	90 f4       	brcc	.+36     	; 0x4fa <LcdGotoXYFont+0x2e>
        return OUT_OF_BORDER;
    /*  Calculate index. It is defined as address within 504 bytes memory */

    LcdCacheIdx = ( x - 1 ) * 6 + ( y - 1 ) * 84;
 4d6:	86 e0       	ldi	r24, 0x06	; 6
 4d8:	98 9f       	mul	r25, r24
 4da:	c0 01       	movw	r24, r0
 4dc:	11 24       	eor	r1, r1
 4de:	8a 55       	subi	r24, 0x5A	; 90
 4e0:	90 40       	sbci	r25, 0x00	; 0
 4e2:	24 e5       	ldi	r18, 0x54	; 84
 4e4:	62 9f       	mul	r22, r18
 4e6:	90 01       	movw	r18, r0
 4e8:	11 24       	eor	r1, r1
 4ea:	82 0f       	add	r24, r18
 4ec:	93 1f       	adc	r25, r19
 4ee:	90 93 59 02 	sts	0x0259, r25
 4f2:	80 93 58 02 	sts	0x0258, r24
 4f6:	80 e0       	ldi	r24, 0x00	; 0
 4f8:	08 95       	ret
    return OK;
 4fa:	81 e0       	ldi	r24, 0x01	; 1
}
 4fc:	08 95       	ret

000004fe <LcdChr>:
 * Argument(s)  :  size -> Font size. See enum in pcd8544.h.
 *                 ch   -> Character to write.
 * Return value :  see pcd8544.h about return value
 */
byte LcdChr ( LcdFontSize size, byte ch )
{
 4fe:	bf 92       	push	r11
 500:	cf 92       	push	r12
 502:	df 92       	push	r13
 504:	ef 92       	push	r14
 506:	ff 92       	push	r15
 508:	0f 93       	push	r16
 50a:	1f 93       	push	r17
 50c:	cf 93       	push	r28
 50e:	df 93       	push	r29
 510:	28 2f       	mov	r18, r24
    byte i, c;
    byte b1, b2;
    int  tmpIdx;

    if ( LcdCacheIdx < LoWaterMark )
 512:	a0 91 58 02 	lds	r26, 0x0258
 516:	b0 91 59 02 	lds	r27, 0x0259
 51a:	80 91 5a 02 	lds	r24, 0x025A
 51e:	90 91 5b 02 	lds	r25, 0x025B
 522:	a8 17       	cp	r26, r24
 524:	b9 07       	cpc	r27, r25
 526:	24 f4       	brge	.+8      	; 0x530 <LcdChr+0x32>
    {
        /* Update low marker. */
        LoWaterMark = LcdCacheIdx;
 528:	b0 93 5b 02 	sts	0x025B, r27
 52c:	a0 93 5a 02 	sts	0x025A, r26
    }

    if ( (ch < 0x20) || (ch > 0x7b) )
 530:	86 2f       	mov	r24, r22
 532:	80 52       	subi	r24, 0x20	; 32
 534:	8c 35       	cpi	r24, 0x5C	; 92
 536:	08 f0       	brcs	.+2      	; 0x53a <LcdChr+0x3c>
 538:	6c e5       	ldi	r22, 0x5C	; 92
    {
        /* Convert to a printable character. */
        ch = 92;
    }

    if ( size == FONT_1X )
 53a:	21 30       	cpi	r18, 0x01	; 1
 53c:	d1 f4       	brne	.+52     	; 0x572 <LcdChr+0x74>
    {
        for ( i = 0; i < 5; i++ )
        {
            /* Copy lookup table from Flash ROM to LcdCache */
            LcdCache[LcdCacheIdx++] = pgm_read_byte(&( FontLookup[ ch - 32 ][ i ] ) ) << 1;
 53e:	85 e0       	ldi	r24, 0x05	; 5
 540:	68 9f       	mul	r22, r24
 542:	c0 01       	movw	r24, r0
 544:	11 24       	eor	r1, r1
 546:	fc 01       	movw	r30, r24
 548:	e3 57       	subi	r30, 0x73	; 115
 54a:	fe 4f       	sbci	r31, 0xFE	; 254
 54c:	ed 01       	movw	r28, r26
 54e:	c0 5a       	subi	r28, 0xA0	; 160
 550:	df 4f       	sbci	r29, 0xFF	; 255
        ch = 92;
    }

    if ( size == FONT_1X )
    {
        for ( i = 0; i < 5; i++ )
 552:	bc 01       	movw	r22, r24
 554:	6e 56       	subi	r22, 0x6E	; 110
 556:	7e 4f       	sbci	r23, 0xFE	; 254
        {
            /* Copy lookup table from Flash ROM to LcdCache */
            LcdCache[LcdCacheIdx++] = pgm_read_byte(&( FontLookup[ ch - 32 ][ i ] ) ) << 1;
 558:	84 91       	lpm	r24, Z+
 55a:	88 0f       	add	r24, r24
 55c:	89 93       	st	Y+, r24
 55e:	31 96       	adiw	r30, 0x01	; 1
        ch = 92;
    }

    if ( size == FONT_1X )
    {
        for ( i = 0; i < 5; i++ )
 560:	e6 17       	cp	r30, r22
 562:	f7 07       	cpc	r31, r23
 564:	c9 f7       	brne	.-14     	; 0x558 <LcdChr+0x5a>
 566:	15 96       	adiw	r26, 0x05	; 5
 568:	b0 93 59 02 	sts	0x0259, r27
 56c:	a0 93 58 02 	sts	0x0258, r26
 570:	9d c0       	rjmp	.+314    	; 0x6ac <LcdChr+0x1ae>
        {
            /* Copy lookup table from Flash ROM to LcdCache */
            LcdCache[LcdCacheIdx++] = pgm_read_byte(&( FontLookup[ ch - 32 ][ i ] ) ) << 1;
        }
    }
    else if ( size == FONT_2X )
 572:	22 30       	cpi	r18, 0x02	; 2
 574:	09 f0       	breq	.+2      	; 0x578 <LcdChr+0x7a>
 576:	9a c0       	rjmp	.+308    	; 0x6ac <LcdChr+0x1ae>
    {
        tmpIdx = LcdCacheIdx - 84;
 578:	9d 01       	movw	r18, r26
 57a:	24 55       	subi	r18, 0x54	; 84
 57c:	30 40       	sbci	r19, 0x00	; 0

        if ( tmpIdx < LoWaterMark )
 57e:	80 91 5a 02 	lds	r24, 0x025A
 582:	90 91 5b 02 	lds	r25, 0x025B
 586:	28 17       	cp	r18, r24
 588:	39 07       	cpc	r19, r25
 58a:	24 f4       	brge	.+8      	; 0x594 <LcdChr+0x96>
        {
            LoWaterMark = tmpIdx;
 58c:	30 93 5b 02 	sts	0x025B, r19
 590:	20 93 5a 02 	sts	0x025A, r18
        }

        if ( tmpIdx < 0 ) return OUT_OF_BORDER;
 594:	37 ff       	sbrs	r19, 7
 596:	02 c0       	rjmp	.+4      	; 0x59c <LcdChr+0x9e>
 598:	81 e0       	ldi	r24, 0x01	; 1
 59a:	ac c0       	rjmp	.+344    	; 0x6f4 <LcdChr+0x1f6>

        for ( i = 0; i < 5; i++ )
        {
            /* Copy lookup table from Flash ROM to temporary c */
            c = pgm_read_byte(&(FontLookup[ch - 32][i])) << 1;
 59c:	85 e0       	ldi	r24, 0x05	; 5
 59e:	68 9f       	mul	r22, r24
 5a0:	c0 01       	movw	r24, r0
 5a2:	11 24       	eor	r1, r1
 5a4:	4d e8       	ldi	r20, 0x8D	; 141
 5a6:	e4 2e       	mov	r14, r20
 5a8:	41 e0       	ldi	r20, 0x01	; 1
 5aa:	f4 2e       	mov	r15, r20
 5ac:	e8 0e       	add	r14, r24
 5ae:	f9 1e       	adc	r15, r25
 5b0:	89 01       	movw	r16, r18
 5b2:	00 5a       	subi	r16, 0xA0	; 160
 5b4:	1f 4f       	sbci	r17, 0xFF	; 255
 5b6:	ed 01       	movw	r28, r26
 5b8:	c0 5a       	subi	r28, 0xA0	; 160
 5ba:	df 4f       	sbci	r29, 0xFF	; 255
            LoWaterMark = tmpIdx;
        }

        if ( tmpIdx < 0 ) return OUT_OF_BORDER;

        for ( i = 0; i < 5; i++ )
 5bc:	32 e9       	ldi	r19, 0x92	; 146
 5be:	c3 2e       	mov	r12, r19
 5c0:	31 e0       	ldi	r19, 0x01	; 1
 5c2:	d3 2e       	mov	r13, r19
 5c4:	c8 0e       	add	r12, r24
 5c6:	d9 1e       	adc	r13, r25
        {
            /* Copy lookup table from Flash ROM to temporary c */
            c = pgm_read_byte(&(FontLookup[ch - 32][i])) << 1;
 5c8:	f7 01       	movw	r30, r14
 5ca:	64 91       	lpm	r22, Z+
 5cc:	66 0f       	add	r22, r22
            /* Enlarge image */
            /* First part */
            b1 =  (c & 0x01) * 3;
 5ce:	46 2f       	mov	r20, r22
 5d0:	50 e0       	ldi	r21, 0x00	; 0
            b1 |= (c & 0x02) * 6;
            b1 |= (c & 0x04) * 12;
            b1 |= (c & 0x08) * 24;
 5d2:	ca 01       	movw	r24, r20
 5d4:	84 70       	andi	r24, 0x04	; 4
 5d6:	90 70       	andi	r25, 0x00	; 0
 5d8:	fc 01       	movw	r30, r24
 5da:	ee 0f       	add	r30, r30
 5dc:	ff 1f       	adc	r31, r31
 5de:	e8 0f       	add	r30, r24
 5e0:	f9 1f       	adc	r31, r25
 5e2:	ee 0f       	add	r30, r30
 5e4:	ff 1f       	adc	r31, r31
 5e6:	ee 0f       	add	r30, r30
 5e8:	ff 1f       	adc	r31, r31
 5ea:	9a 01       	movw	r18, r20
 5ec:	22 70       	andi	r18, 0x02	; 2
 5ee:	30 70       	andi	r19, 0x00	; 0
 5f0:	c9 01       	movw	r24, r18
 5f2:	88 0f       	add	r24, r24
 5f4:	99 1f       	adc	r25, r25
 5f6:	82 0f       	add	r24, r18
 5f8:	93 1f       	adc	r25, r19
 5fa:	88 0f       	add	r24, r24
 5fc:	99 1f       	adc	r25, r25
 5fe:	be 2e       	mov	r11, r30
 600:	b8 2a       	or	r11, r24
 602:	48 70       	andi	r20, 0x08	; 8
 604:	50 70       	andi	r21, 0x00	; 0
 606:	ca 01       	movw	r24, r20
 608:	88 0f       	add	r24, r24
 60a:	99 1f       	adc	r25, r25
 60c:	84 0f       	add	r24, r20
 60e:	95 1f       	adc	r25, r21
 610:	73 e0       	ldi	r23, 0x03	; 3
 612:	88 0f       	add	r24, r24
 614:	99 1f       	adc	r25, r25
 616:	7a 95       	dec	r23
 618:	e1 f7       	brne	.-8      	; 0x612 <LcdChr+0x114>
 61a:	b8 2a       	or	r11, r24

            c >>= 4;
            /* Second part */
            b2 =  (c & 0x01) * 3;
 61c:	62 95       	swap	r22
 61e:	6f 70       	andi	r22, 0x0F	; 15
 620:	70 e0       	ldi	r23, 0x00	; 0
            b2 |= (c & 0x02) * 6;
            b2 |= (c & 0x04) * 12;
            b2 |= (c & 0x08) * 24;
 622:	cb 01       	movw	r24, r22
 624:	84 70       	andi	r24, 0x04	; 4
 626:	90 70       	andi	r25, 0x00	; 0
 628:	9c 01       	movw	r18, r24
 62a:	22 0f       	add	r18, r18
 62c:	33 1f       	adc	r19, r19
 62e:	28 0f       	add	r18, r24
 630:	39 1f       	adc	r19, r25
 632:	22 0f       	add	r18, r18
 634:	33 1f       	adc	r19, r19
 636:	22 0f       	add	r18, r18
 638:	33 1f       	adc	r19, r19
 63a:	ab 01       	movw	r20, r22
 63c:	42 70       	andi	r20, 0x02	; 2
 63e:	50 70       	andi	r21, 0x00	; 0
 640:	ca 01       	movw	r24, r20
 642:	88 0f       	add	r24, r24
 644:	99 1f       	adc	r25, r25
 646:	84 0f       	add	r24, r20
 648:	95 1f       	adc	r25, r21
 64a:	88 0f       	add	r24, r24
 64c:	99 1f       	adc	r25, r25
 64e:	28 2b       	or	r18, r24
 650:	ab 01       	movw	r20, r22
 652:	48 70       	andi	r20, 0x08	; 8
 654:	50 70       	andi	r21, 0x00	; 0
 656:	ca 01       	movw	r24, r20
 658:	88 0f       	add	r24, r24
 65a:	99 1f       	adc	r25, r25
 65c:	84 0f       	add	r24, r20
 65e:	95 1f       	adc	r25, r21
 660:	43 e0       	ldi	r20, 0x03	; 3
 662:	88 0f       	add	r24, r24
 664:	99 1f       	adc	r25, r25
 666:	4a 95       	dec	r20
 668:	e1 f7       	brne	.-8      	; 0x662 <LcdChr+0x164>
 66a:	28 2b       	or	r18, r24
 66c:	61 70       	andi	r22, 0x01	; 1
 66e:	70 70       	andi	r23, 0x00	; 0
 670:	cb 01       	movw	r24, r22
 672:	88 0f       	add	r24, r24
 674:	99 1f       	adc	r25, r25
 676:	86 0f       	add	r24, r22
 678:	97 1f       	adc	r25, r23
 67a:	28 2b       	or	r18, r24

            /* Copy two parts into LcdCache */
            LcdCache[tmpIdx++] = b1;
 67c:	f8 01       	movw	r30, r16
 67e:	b0 82       	st	Z, r11
            LcdCache[tmpIdx++] = b1;
 680:	b1 82       	std	Z+1, r11	; 0x01
            LcdCache[tmpIdx + 82] = b2;
 682:	28 83       	st	Y, r18
            LcdCache[tmpIdx + 83] = b2;
 684:	29 83       	std	Y+1, r18	; 0x01
 686:	08 94       	sec
 688:	e1 1c       	adc	r14, r1
 68a:	f1 1c       	adc	r15, r1
 68c:	0e 5f       	subi	r16, 0xFE	; 254
 68e:	1f 4f       	sbci	r17, 0xFF	; 255
 690:	22 96       	adiw	r28, 0x02	; 2
            LoWaterMark = tmpIdx;
        }

        if ( tmpIdx < 0 ) return OUT_OF_BORDER;

        for ( i = 0; i < 5; i++ )
 692:	ec 14       	cp	r14, r12
 694:	fd 04       	cpc	r15, r13
 696:	09 f0       	breq	.+2      	; 0x69a <LcdChr+0x19c>
 698:	97 cf       	rjmp	.-210    	; 0x5c8 <LcdChr+0xca>
            LcdCache[tmpIdx + 83] = b2;
        }

        /* Update x cursor position. */
        /* Version 0.2.5 - Possible bug fixed on Dec 25,2008 */
        LcdCacheIdx = (LcdCacheIdx + 11) % LCD_CACHE_SIZE;
 69a:	cd 01       	movw	r24, r26
 69c:	0b 96       	adiw	r24, 0x0b	; 11
 69e:	68 ef       	ldi	r22, 0xF8	; 248
 6a0:	71 e0       	ldi	r23, 0x01	; 1
 6a2:	ce d2       	rcall	.+1436   	; 0xc40 <__divmodhi4>
 6a4:	90 93 59 02 	sts	0x0259, r25
 6a8:	80 93 58 02 	sts	0x0258, r24
    }

    if ( LcdCacheIdx > HiWaterMark )
 6ac:	20 91 58 02 	lds	r18, 0x0258
 6b0:	30 91 59 02 	lds	r19, 0x0259
 6b4:	80 91 5c 02 	lds	r24, 0x025C
 6b8:	90 91 5d 02 	lds	r25, 0x025D
 6bc:	82 17       	cp	r24, r18
 6be:	93 07       	cpc	r25, r19
 6c0:	24 f4       	brge	.+8      	; 0x6ca <LcdChr+0x1cc>
    {
        /* Update high marker. */
        HiWaterMark = LcdCacheIdx;
 6c2:	30 93 5d 02 	sts	0x025D, r19
 6c6:	20 93 5c 02 	sts	0x025C, r18
    }

    /* Horizontal gap between characters. */
    /* Version 0.2.5 - Possible bug fixed on Dec 25,2008 */
    LcdCache[LcdCacheIdx] = 0x00;
 6ca:	f9 01       	movw	r30, r18
 6cc:	e0 5a       	subi	r30, 0xA0	; 160
 6ce:	ff 4f       	sbci	r31, 0xFF	; 255
 6d0:	10 82       	st	Z, r1
    /* At index number LCD_CACHE_SIZE - 1, wrap to 0 */
    if(LcdCacheIdx == (LCD_CACHE_SIZE - 1) )
 6d2:	f1 e0       	ldi	r31, 0x01	; 1
 6d4:	27 3f       	cpi	r18, 0xF7	; 247
 6d6:	3f 07       	cpc	r19, r31
 6d8:	31 f4       	brne	.+12     	; 0x6e6 <LcdChr+0x1e8>
    {
        LcdCacheIdx = 0;
 6da:	10 92 59 02 	sts	0x0259, r1
 6de:	10 92 58 02 	sts	0x0258, r1
 6e2:	82 e0       	ldi	r24, 0x02	; 2
 6e4:	07 c0       	rjmp	.+14     	; 0x6f4 <LcdChr+0x1f6>
        return OK_WITH_WRAP;
    }
    /* Otherwise just increment the index */
    LcdCacheIdx++;
 6e6:	2f 5f       	subi	r18, 0xFF	; 255
 6e8:	3f 4f       	sbci	r19, 0xFF	; 255
 6ea:	30 93 59 02 	sts	0x0259, r19
 6ee:	20 93 58 02 	sts	0x0258, r18
 6f2:	80 e0       	ldi	r24, 0x00	; 0
    return OK;
}
 6f4:	df 91       	pop	r29
 6f6:	cf 91       	pop	r28
 6f8:	1f 91       	pop	r17
 6fa:	0f 91       	pop	r16
 6fc:	ff 90       	pop	r15
 6fe:	ef 90       	pop	r14
 700:	df 90       	pop	r13
 702:	cf 90       	pop	r12
 704:	bf 90       	pop	r11
 706:	08 95       	ret

00000708 <LcdStr>:
 *                 dataArray -> Array contained string of char to be written
 *                              into cache.
 * Return value :  see return value on pcd8544.h
 */
byte LcdStr ( LcdFontSize size, byte dataArray[] )
{
 708:	0f 93       	push	r16
 70a:	1f 93       	push	r17
 70c:	cf 93       	push	r28
 70e:	df 93       	push	r29
 710:	08 2f       	mov	r16, r24
 712:	eb 01       	movw	r28, r22
 714:	10 e0       	ldi	r17, 0x00	; 0
 716:	05 c0       	rjmp	.+10     	; 0x722 <LcdStr+0x1a>
    byte tmpIdx=0;
    byte response;
    while( dataArray[ tmpIdx ] != '\0' )
	{
        /* Send char */
		response = LcdChr( size, dataArray[ tmpIdx ] );
 718:	80 2f       	mov	r24, r16
 71a:	f1 de       	rcall	.-542    	; 0x4fe <LcdChr>
        /* Just in case OUT_OF_BORDER occured */
        /* Dont worry if the signal == OK_WITH_WRAP, the string will
        be wrapped to starting point */
        if( response == OUT_OF_BORDER)
 71c:	81 30       	cpi	r24, 0x01	; 1
 71e:	41 f0       	breq	.+16     	; 0x730 <LcdStr+0x28>
            return OUT_OF_BORDER;
        /* Increase index */
		tmpIdx++;
 720:	1f 5f       	subi	r17, 0xFF	; 255
 */
byte LcdStr ( LcdFontSize size, byte dataArray[] )
{
    byte tmpIdx=0;
    byte response;
    while( dataArray[ tmpIdx ] != '\0' )
 722:	fe 01       	movw	r30, r28
 724:	e1 0f       	add	r30, r17
 726:	f1 1d       	adc	r31, r1
 728:	60 81       	ld	r22, Z
 72a:	66 23       	and	r22, r22
 72c:	a9 f7       	brne	.-22     	; 0x718 <LcdStr+0x10>
 72e:	80 e0       	ldi	r24, 0x00	; 0
            return OUT_OF_BORDER;
        /* Increase index */
		tmpIdx++;
	}
    return OK;
}
 730:	df 91       	pop	r29
 732:	cf 91       	pop	r28
 734:	1f 91       	pop	r17
 736:	0f 91       	pop	r16
 738:	08 95       	ret

0000073a <LcdFStr>:
 * Return value :  see return value on pcd8544.h
 * Example      :  LcdFStr(FONT_1X, PSTR("Hello World"));
 *                 LcdFStr(FONT_1X, &name_of_string_as_array);
 */
byte LcdFStr ( LcdFontSize size, const byte *dataPtr )
{
 73a:	1f 93       	push	r17
 73c:	cf 93       	push	r28
 73e:	df 93       	push	r29
 740:	18 2f       	mov	r17, r24
 742:	eb 01       	movw	r28, r22
    byte c;
    byte response;
    for ( c = pgm_read_byte( dataPtr ); c; ++dataPtr, c = pgm_read_byte( dataPtr ) )
 744:	fb 01       	movw	r30, r22
 746:	64 91       	lpm	r22, Z+
 748:	07 c0       	rjmp	.+14     	; 0x758 <LcdFStr+0x1e>
    {
        /* Put char */
        response = LcdChr( size, c );
 74a:	81 2f       	mov	r24, r17
 74c:	d8 de       	rcall	.-592    	; 0x4fe <LcdChr>
        if(response == OUT_OF_BORDER)
 74e:	81 30       	cpi	r24, 0x01	; 1
 750:	31 f0       	breq	.+12     	; 0x75e <LcdFStr+0x24>
 */
byte LcdFStr ( LcdFontSize size, const byte *dataPtr )
{
    byte c;
    byte response;
    for ( c = pgm_read_byte( dataPtr ); c; ++dataPtr, c = pgm_read_byte( dataPtr ) )
 752:	21 96       	adiw	r28, 0x01	; 1
 754:	fe 01       	movw	r30, r28
 756:	64 91       	lpm	r22, Z+
 758:	66 23       	and	r22, r22
 75a:	b9 f7       	brne	.-18     	; 0x74a <LcdFStr+0x10>
 75c:	80 e0       	ldi	r24, 0x00	; 0
        if(response == OUT_OF_BORDER)
            return OUT_OF_BORDER;
    }
	/* Fixed by Jakub Lasinski. Version 0.2.6, March 14, 2009 */
    return OK;
}
 75e:	df 91       	pop	r29
 760:	cf 91       	pop	r28
 762:	1f 91       	pop	r17
 764:	08 95       	ret

00000766 <LcdPixel>:
 *                 mode -> Off, On or Xor. See enum in pcd8544.h.
 * Return value :  see return value on pcd8544.h
 * Note         :  Based on Sylvain Bissonette's code
 */
byte LcdPixel ( byte x, byte y, LcdPixelMode mode )
{
 766:	58 2f       	mov	r21, r24
    word  index;
    byte  offset;
    byte  data;

    /* Prevent from getting out of border */
    if ( x > LCD_X_RES ) return OUT_OF_BORDER;
 768:	85 35       	cpi	r24, 0x55	; 85
 76a:	08 f0       	brcs	.+2      	; 0x76e <LcdPixel+0x8>
 76c:	5a c0       	rjmp	.+180    	; 0x822 <LcdPixel+0xbc>
    if ( y > LCD_Y_RES ) return OUT_OF_BORDER;
 76e:	61 33       	cpi	r22, 0x31	; 49
 770:	08 f0       	brcs	.+2      	; 0x774 <LcdPixel+0xe>
 772:	57 c0       	rjmp	.+174    	; 0x822 <LcdPixel+0xbc>

    /* Recalculating index and offset */
    index = ( ( y / 8 ) * 84 ) + x;
 774:	86 2f       	mov	r24, r22
 776:	86 95       	lsr	r24
 778:	86 95       	lsr	r24
 77a:	86 95       	lsr	r24
 77c:	90 e0       	ldi	r25, 0x00	; 0
 77e:	24 e5       	ldi	r18, 0x54	; 84
 780:	30 e0       	ldi	r19, 0x00	; 0
 782:	82 9f       	mul	r24, r18
 784:	d0 01       	movw	r26, r0
 786:	83 9f       	mul	r24, r19
 788:	b0 0d       	add	r27, r0
 78a:	92 9f       	mul	r25, r18
 78c:	b0 0d       	add	r27, r0
 78e:	11 24       	eor	r1, r1
 790:	a5 0f       	add	r26, r21
 792:	b1 1d       	adc	r27, r1
    offset  = y - ( ( y / 8 ) * 8 );
 794:	53 e0       	ldi	r21, 0x03	; 3
 796:	88 0f       	add	r24, r24
 798:	99 1f       	adc	r25, r25
 79a:	5a 95       	dec	r21
 79c:	e1 f7       	brne	.-8      	; 0x796 <LcdPixel+0x30>
 79e:	68 1b       	sub	r22, r24

    data = LcdCache[ index ];
 7a0:	fd 01       	movw	r30, r26
 7a2:	e0 5a       	subi	r30, 0xA0	; 160
 7a4:	ff 4f       	sbci	r31, 0xFF	; 255
 7a6:	20 81       	ld	r18, Z

    /* Bit processing */

	/* Clear mode */
    if ( mode == PIXEL_OFF )
 7a8:	44 23       	and	r20, r20
 7aa:	51 f4       	brne	.+20     	; 0x7c0 <LcdPixel+0x5a>
    {
        data &= ( ~( 0x01 << offset ) );
 7ac:	81 e0       	ldi	r24, 0x01	; 1
 7ae:	90 e0       	ldi	r25, 0x00	; 0
 7b0:	02 c0       	rjmp	.+4      	; 0x7b6 <LcdPixel+0x50>
 7b2:	88 0f       	add	r24, r24
 7b4:	99 1f       	adc	r25, r25
 7b6:	6a 95       	dec	r22
 7b8:	e2 f7       	brpl	.-8      	; 0x7b2 <LcdPixel+0x4c>
 7ba:	80 95       	com	r24
 7bc:	28 23       	and	r18, r24
 7be:	15 c0       	rjmp	.+42     	; 0x7ea <LcdPixel+0x84>
    }

    /* On mode */
    else if ( mode == PIXEL_ON )
 7c0:	41 30       	cpi	r20, 0x01	; 1
 7c2:	49 f4       	brne	.+18     	; 0x7d6 <LcdPixel+0x70>
    {
        data |= ( 0x01 << offset );
 7c4:	81 e0       	ldi	r24, 0x01	; 1
 7c6:	90 e0       	ldi	r25, 0x00	; 0
 7c8:	02 c0       	rjmp	.+4      	; 0x7ce <LcdPixel+0x68>
 7ca:	88 0f       	add	r24, r24
 7cc:	99 1f       	adc	r25, r25
 7ce:	6a 95       	dec	r22
 7d0:	e2 f7       	brpl	.-8      	; 0x7ca <LcdPixel+0x64>
 7d2:	28 2b       	or	r18, r24
 7d4:	0a c0       	rjmp	.+20     	; 0x7ea <LcdPixel+0x84>
    }

    /* Xor mode */
    else if ( mode  == PIXEL_XOR )
 7d6:	42 30       	cpi	r20, 0x02	; 2
 7d8:	41 f4       	brne	.+16     	; 0x7ea <LcdPixel+0x84>
    {
        data ^= ( 0x01 << offset );
 7da:	81 e0       	ldi	r24, 0x01	; 1
 7dc:	90 e0       	ldi	r25, 0x00	; 0
 7de:	02 c0       	rjmp	.+4      	; 0x7e4 <LcdPixel+0x7e>
 7e0:	88 0f       	add	r24, r24
 7e2:	99 1f       	adc	r25, r25
 7e4:	6a 95       	dec	r22
 7e6:	e2 f7       	brpl	.-8      	; 0x7e0 <LcdPixel+0x7a>
 7e8:	28 27       	eor	r18, r24
    }

    /* Final result copied to cache */
    LcdCache[ index ] = data;
 7ea:	fd 01       	movw	r30, r26
 7ec:	e0 5a       	subi	r30, 0xA0	; 160
 7ee:	ff 4f       	sbci	r31, 0xFF	; 255
 7f0:	20 83       	st	Z, r18

    if ( index < LoWaterMark )
 7f2:	80 91 5a 02 	lds	r24, 0x025A
 7f6:	90 91 5b 02 	lds	r25, 0x025B
 7fa:	a8 17       	cp	r26, r24
 7fc:	b9 07       	cpc	r27, r25
 7fe:	20 f4       	brcc	.+8      	; 0x808 <LcdPixel+0xa2>
    {
        /*  Update low marker. */
        LoWaterMark = index;
 800:	b0 93 5b 02 	sts	0x025B, r27
 804:	a0 93 5a 02 	sts	0x025A, r26
    }

    if ( index > HiWaterMark )
 808:	80 91 5c 02 	lds	r24, 0x025C
 80c:	90 91 5d 02 	lds	r25, 0x025D
 810:	8a 17       	cp	r24, r26
 812:	9b 07       	cpc	r25, r27
 814:	20 f4       	brcc	.+8      	; 0x81e <LcdPixel+0xb8>
    {
        /*  Update high marker. */
        HiWaterMark = index;
 816:	b0 93 5d 02 	sts	0x025D, r27
 81a:	a0 93 5c 02 	sts	0x025C, r26
 81e:	80 e0       	ldi	r24, 0x00	; 0
 820:	08 95       	ret
 822:	81 e0       	ldi	r24, 0x01	; 1
    }
    return OK;
}
 824:	08 95       	ret

00000826 <LcdLine>:
 *                 x2, y2 -> Absolute pixel coordinates for line end.
 *                 mode   -> Off, On or Xor. See enum in pcd8544.h.
 * Return value :  see return value on pcd8544.h
 */
byte LcdLine ( byte x1, byte x2, byte y1, byte y2, LcdPixelMode mode )
{
 826:	5f 92       	push	r5
 828:	6f 92       	push	r6
 82a:	7f 92       	push	r7
 82c:	8f 92       	push	r8
 82e:	9f 92       	push	r9
 830:	af 92       	push	r10
 832:	bf 92       	push	r11
 834:	cf 92       	push	r12
 836:	df 92       	push	r13
 838:	ef 92       	push	r14
 83a:	ff 92       	push	r15
 83c:	0f 93       	push	r16
 83e:	1f 93       	push	r17
 840:	cf 93       	push	r28
 842:	df 93       	push	r29
 844:	c8 2e       	mov	r12, r24
 846:	56 2e       	mov	r5, r22
 848:	d4 2e       	mov	r13, r20
 84a:	62 2e       	mov	r6, r18
 84c:	70 2e       	mov	r7, r16
    /* dy   y2 - y1 */
    /* -- = ------- */
    /* dx   x2 - x1 */

    /* Take differences */
    dy = y2 - y1;
 84e:	02 2f       	mov	r16, r18
 850:	10 e0       	ldi	r17, 0x00	; 0
 852:	04 1b       	sub	r16, r20
 854:	11 09       	sbc	r17, r1
    dx = x2 - x1;
 856:	c6 2f       	mov	r28, r22
 858:	d0 e0       	ldi	r29, 0x00	; 0
 85a:	c8 1b       	sub	r28, r24
 85c:	d1 09       	sbc	r29, r1

    /* dy is negative */
    if ( dy < 0 )
 85e:	17 fd       	sbrc	r17, 7
 860:	04 c0       	rjmp	.+8      	; 0x86a <LcdLine+0x44>
 862:	b1 e0       	ldi	r27, 0x01	; 1
 864:	8b 2e       	mov	r8, r27
 866:	91 2c       	mov	r9, r1
 868:	06 c0       	rjmp	.+12     	; 0x876 <LcdLine+0x50>
    {
        dy    = -dy;
 86a:	10 95       	com	r17
 86c:	01 95       	neg	r16
 86e:	1f 4f       	sbci	r17, 0xFF	; 255
 870:	88 24       	eor	r8, r8
 872:	8a 94       	dec	r8
 874:	98 2c       	mov	r9, r8
    {
        stepy = 1;
    }

    /* dx is negative */
    if ( dx < 0 )
 876:	d7 fd       	sbrc	r29, 7
 878:	04 c0       	rjmp	.+8      	; 0x882 <LcdLine+0x5c>
 87a:	a1 e0       	ldi	r26, 0x01	; 1
 87c:	aa 2e       	mov	r10, r26
 87e:	b1 2c       	mov	r11, r1
 880:	06 c0       	rjmp	.+12     	; 0x88e <LcdLine+0x68>
    {
        dx    = -dx;
 882:	d0 95       	com	r29
 884:	c1 95       	neg	r28
 886:	df 4f       	sbci	r29, 0xFF	; 255
 888:	aa 24       	eor	r10, r10
 88a:	aa 94       	dec	r10
 88c:	ba 2c       	mov	r11, r10

    dx <<= 1;
    dy <<= 1;

    /* Draw initial position */
    response = LcdPixel( x1, y1, mode );
 88e:	8c 2d       	mov	r24, r12
 890:	6d 2d       	mov	r22, r13
 892:	47 2d       	mov	r20, r7
 894:	68 df       	rcall	.-304    	; 0x766 <LcdPixel>
    if(response)
 896:	88 23       	and	r24, r24
 898:	d9 f5       	brne	.+118    	; 0x910 <LcdLine+0xea>
    else
    {
        stepx = 1;
    }

    dx <<= 1;
 89a:	7e 01       	movw	r14, r28
 89c:	ee 0c       	add	r14, r14
 89e:	ff 1c       	adc	r15, r15
    dy <<= 1;
 8a0:	00 0f       	add	r16, r16
 8a2:	11 1f       	adc	r17, r17
    response = LcdPixel( x1, y1, mode );
    if(response)
        return response;

    /* Draw next positions until end */
    if ( dx > dy )
 8a4:	0e 15       	cp	r16, r14
 8a6:	1f 05       	cpc	r17, r15
 8a8:	c4 f4       	brge	.+48     	; 0x8da <LcdLine+0xb4>
    {
        /* Take fraction */
        fraction = dy - ( dx >> 1);
 8aa:	c7 01       	movw	r24, r14
 8ac:	95 95       	asr	r25
 8ae:	87 95       	ror	r24
 8b0:	e8 01       	movw	r28, r16
 8b2:	c8 1b       	sub	r28, r24
 8b4:	d9 0b       	sbc	r29, r25
 8b6:	0e c0       	rjmp	.+28     	; 0x8d4 <LcdLine+0xae>
        while ( x1 != x2 )
        {
            if ( fraction >= 0 )
 8b8:	d7 fd       	sbrc	r29, 7
 8ba:	03 c0       	rjmp	.+6      	; 0x8c2 <LcdLine+0x9c>
            {
                y1 += stepy;
 8bc:	d8 0c       	add	r13, r8
                fraction -= dx;
 8be:	ce 19       	sub	r28, r14
 8c0:	df 09       	sbc	r29, r15
 8c2:	ca 0c       	add	r12, r10
            }
            x1 += stepx;
            fraction += dy;

            /* Draw calculated point */
            response = LcdPixel( x1, y1, mode );
 8c4:	8c 2d       	mov	r24, r12
 8c6:	6d 2d       	mov	r22, r13
 8c8:	47 2d       	mov	r20, r7
 8ca:	4d df       	rcall	.-358    	; 0x766 <LcdPixel>
            if(response)
 8cc:	88 23       	and	r24, r24
 8ce:	01 f5       	brne	.+64     	; 0x910 <LcdLine+0xea>
            {
                y1 += stepy;
                fraction -= dx;
            }
            x1 += stepx;
            fraction += dy;
 8d0:	c0 0f       	add	r28, r16
 8d2:	d1 1f       	adc	r29, r17
    /* Draw next positions until end */
    if ( dx > dy )
    {
        /* Take fraction */
        fraction = dy - ( dx >> 1);
        while ( x1 != x2 )
 8d4:	c5 14       	cp	r12, r5
 8d6:	81 f7       	brne	.-32     	; 0x8b8 <LcdLine+0x92>
 8d8:	17 c0       	rjmp	.+46     	; 0x908 <LcdLine+0xe2>
        }
    }
    else
    {
        /* Take fraction */
        fraction = dx - ( dy >> 1);
 8da:	c8 01       	movw	r24, r16
 8dc:	95 95       	asr	r25
 8de:	87 95       	ror	r24
 8e0:	e7 01       	movw	r28, r14
 8e2:	c8 1b       	sub	r28, r24
 8e4:	d9 0b       	sbc	r29, r25
 8e6:	0e c0       	rjmp	.+28     	; 0x904 <LcdLine+0xde>
        while ( y1 != y2 )
        {
            if ( fraction >= 0 )
 8e8:	d7 fd       	sbrc	r29, 7
 8ea:	03 c0       	rjmp	.+6      	; 0x8f2 <LcdLine+0xcc>
            {
                x1 += stepx;
 8ec:	ca 0c       	add	r12, r10
                fraction -= dy;
 8ee:	c0 1b       	sub	r28, r16
 8f0:	d1 0b       	sbc	r29, r17
 8f2:	d8 0c       	add	r13, r8
            }
            y1 += stepy;
            fraction += dx;

            /* Draw calculated point */
            response = LcdPixel( x1, y1, mode );
 8f4:	8c 2d       	mov	r24, r12
 8f6:	6d 2d       	mov	r22, r13
 8f8:	47 2d       	mov	r20, r7
 8fa:	35 df       	rcall	.-406    	; 0x766 <LcdPixel>
            if(response)
 8fc:	88 23       	and	r24, r24
 8fe:	41 f4       	brne	.+16     	; 0x910 <LcdLine+0xea>
            {
                x1 += stepx;
                fraction -= dy;
            }
            y1 += stepy;
            fraction += dx;
 900:	ce 0d       	add	r28, r14
 902:	df 1d       	adc	r29, r15
    }
    else
    {
        /* Take fraction */
        fraction = dx - ( dy >> 1);
        while ( y1 != y2 )
 904:	d6 14       	cp	r13, r6
 906:	81 f7       	brne	.-32     	; 0x8e8 <LcdLine+0xc2>
                return response;
        }
    }

    /* Set update flag to be true */
    UpdateLcd = TRUE;
 908:	81 e0       	ldi	r24, 0x01	; 1
 90a:	80 93 5e 02 	sts	0x025E, r24
 90e:	80 e0       	ldi	r24, 0x00	; 0
    return OK;
}
 910:	df 91       	pop	r29
 912:	cf 91       	pop	r28
 914:	1f 91       	pop	r17
 916:	0f 91       	pop	r16
 918:	ff 90       	pop	r15
 91a:	ef 90       	pop	r14
 91c:	df 90       	pop	r13
 91e:	cf 90       	pop	r12
 920:	bf 90       	pop	r11
 922:	af 90       	pop	r10
 924:	9f 90       	pop	r9
 926:	8f 90       	pop	r8
 928:	7f 90       	pop	r7
 92a:	6f 90       	pop	r6
 92c:	5f 90       	pop	r5
 92e:	08 95       	ret

00000930 <LcdSingleBar>:
 *				   width  -> width of bar (in pixel)
 *				   mode   -> Off, On or Xor. See enum in pcd8544.h.
 * Return value :  see return value on pcd8544.h
 */
byte LcdSingleBar ( byte baseX, byte baseY, byte height, byte width, LcdPixelMode mode )
{
 930:	df 92       	push	r13
 932:	ef 92       	push	r14
 934:	ff 92       	push	r15
 936:	0f 93       	push	r16
 938:	1f 93       	push	r17
 93a:	cf 93       	push	r28
 93c:	df 93       	push	r29
 93e:	e8 2e       	mov	r14, r24
 940:	f6 2e       	mov	r15, r22
 942:	d0 2e       	mov	r13, r16
	byte tmpIdxX,tmpIdxY,tmp;

    byte response;

    /* Checking border */
	if ( ( baseX > LCD_X_RES ) || ( baseY > LCD_Y_RES ) ) return OUT_OF_BORDER;
 944:	84 e5       	ldi	r24, 0x54	; 84
 946:	8e 15       	cp	r24, r14
 948:	28 f1       	brcs	.+74     	; 0x994 <LcdSingleBar+0x64>
 94a:	80 e3       	ldi	r24, 0x30	; 48
 94c:	86 17       	cp	r24, r22
 94e:	10 f1       	brcs	.+68     	; 0x994 <LcdSingleBar+0x64>

	if ( height > baseY )
 950:	64 17       	cp	r22, r20
 952:	10 f4       	brcc	.+4      	; 0x958 <LcdSingleBar+0x28>
 954:	00 e0       	ldi	r16, 0x00	; 0
 956:	11 c0       	rjmp	.+34     	; 0x97a <LcdSingleBar+0x4a>
		tmp = 0;
	else
		tmp = baseY - height;
 958:	06 2f       	mov	r16, r22
 95a:	04 1b       	sub	r16, r20
 95c:	0e c0       	rjmp	.+28     	; 0x97a <LcdSingleBar+0x4a>
    /* Draw lines */
	for ( tmpIdxY = tmp; tmpIdxY < baseY; tmpIdxY++ )
	{
		for ( tmpIdxX = baseX; tmpIdxX < (baseX + width); tmpIdxX++ )
        {
			response = LcdPixel( tmpIdxX, tmpIdxY, mode );
 95e:	81 2f       	mov	r24, r17
 960:	60 2f       	mov	r22, r16
 962:	4d 2d       	mov	r20, r13
 964:	00 df       	rcall	.-512    	; 0x766 <LcdPixel>
            if(response)
 966:	88 23       	and	r24, r24
 968:	b1 f4       	brne	.+44     	; 0x996 <LcdSingleBar+0x66>
		tmp = baseY - height;

    /* Draw lines */
	for ( tmpIdxY = tmp; tmpIdxY < baseY; tmpIdxY++ )
	{
		for ( tmpIdxX = baseX; tmpIdxX < (baseX + width); tmpIdxX++ )
 96a:	1f 5f       	subi	r17, 0xFF	; 255
 96c:	81 2f       	mov	r24, r17
 96e:	90 e0       	ldi	r25, 0x00	; 0
 970:	8c 17       	cp	r24, r28
 972:	9d 07       	cpc	r25, r29
 974:	a4 f3       	brlt	.-24     	; 0x95e <LcdSingleBar+0x2e>
		tmp = 0;
	else
		tmp = baseY - height;

    /* Draw lines */
	for ( tmpIdxY = tmp; tmpIdxY < baseY; tmpIdxY++ )
 976:	0f 5f       	subi	r16, 0xFF	; 255
 978:	04 c0       	rjmp	.+8      	; 0x982 <LcdSingleBar+0x52>
	{
		for ( tmpIdxX = baseX; tmpIdxX < (baseX + width); tmpIdxX++ )
 97a:	ce 2d       	mov	r28, r14
 97c:	d0 e0       	ldi	r29, 0x00	; 0
 97e:	c2 0f       	add	r28, r18
 980:	d1 1d       	adc	r29, r1
		tmp = 0;
	else
		tmp = baseY - height;

    /* Draw lines */
	for ( tmpIdxY = tmp; tmpIdxY < baseY; tmpIdxY++ )
 982:	0f 15       	cp	r16, r15
 984:	10 f4       	brcc	.+4      	; 0x98a <LcdSingleBar+0x5a>
 986:	1e 2d       	mov	r17, r14
 988:	f1 cf       	rjmp	.-30     	; 0x96c <LcdSingleBar+0x3c>

        }
	}

    /* Set update flag to be true */
	UpdateLcd = TRUE;
 98a:	81 e0       	ldi	r24, 0x01	; 1
 98c:	80 93 5e 02 	sts	0x025E, r24
 990:	80 e0       	ldi	r24, 0x00	; 0
 992:	01 c0       	rjmp	.+2      	; 0x996 <LcdSingleBar+0x66>
    return OK;
 994:	81 e0       	ldi	r24, 0x01	; 1
}
 996:	df 91       	pop	r29
 998:	cf 91       	pop	r28
 99a:	1f 91       	pop	r17
 99c:	0f 91       	pop	r16
 99e:	ff 90       	pop	r15
 9a0:	ef 90       	pop	r14
 9a2:	df 90       	pop	r13
 9a4:	08 95       	ret

000009a6 <LcdBars>:
 *				   width  -> width of bar (in pixel)
 * Return value :  see return value on pcd8544.h
 * Note         :  Please check EMPTY_SPACE_BARS, BAR_X, BAR_Y in pcd8544.h
 */
byte LcdBars ( byte data[], byte numbBars, byte width, byte multiplier )
{
 9a6:	af 92       	push	r10
 9a8:	bf 92       	push	r11
 9aa:	cf 92       	push	r12
 9ac:	df 92       	push	r13
 9ae:	ef 92       	push	r14
 9b0:	ff 92       	push	r15
 9b2:	0f 93       	push	r16
 9b4:	1f 93       	push	r17
 9b6:	cf 93       	push	r28
 9b8:	df 93       	push	r29
 9ba:	7c 01       	movw	r14, r24
 9bc:	a6 2e       	mov	r10, r22
 9be:	d4 2e       	mov	r13, r20
 9c0:	b2 2e       	mov	r11, r18
 9c2:	12 e0       	ldi	r17, 0x02	; 2
 9c4:	c1 2e       	mov	r12, r17
 9c6:	c4 0e       	add	r12, r20
 9c8:	80 e0       	ldi	r24, 0x00	; 0
 9ca:	c0 e0       	ldi	r28, 0x00	; 0
 9cc:	d0 e0       	ldi	r29, 0x00	; 0
 9ce:	15 e0       	ldi	r17, 0x05	; 5
 9d0:	17 c0       	rjmp	.+46     	; 0xa00 <LcdBars+0x5a>
    byte response;

	for ( b = 0;  b < numbBars ; b++ )
	{
        /* Preventing from out of border (LCD_X_RES) */
		if ( tmpIdx > LCD_X_RES ) return OUT_OF_BORDER;
 9d2:	85 35       	cpi	r24, 0x55	; 85
 9d4:	10 f0       	brcs	.+4      	; 0x9da <LcdBars+0x34>
 9d6:	81 e0       	ldi	r24, 0x01	; 1
 9d8:	19 c0       	rjmp	.+50     	; 0xa0c <LcdBars+0x66>

		/* Calculate x axis */
		tmpIdx = ((width + EMPTY_SPACE_BARS) * b) + BAR_X;

		/* Draw single bar */
		response = LcdSingleBar( tmpIdx, BAR_Y, data[ b ] * multiplier, width, PIXEL_ON);
 9da:	f7 01       	movw	r30, r14
 9dc:	ec 0f       	add	r30, r28
 9de:	fd 1f       	adc	r31, r29
 9e0:	40 81       	ld	r20, Z
 9e2:	b4 9e       	mul	r11, r20
 9e4:	40 2d       	mov	r20, r0
 9e6:	11 24       	eor	r1, r1
 9e8:	81 2f       	mov	r24, r17
 9ea:	66 e2       	ldi	r22, 0x26	; 38
 9ec:	2d 2d       	mov	r18, r13
 9ee:	01 e0       	ldi	r16, 0x01	; 1
 9f0:	9f df       	rcall	.-194    	; 0x930 <LcdSingleBar>
 9f2:	21 96       	adiw	r28, 0x01	; 1
 9f4:	91 2f       	mov	r25, r17
 9f6:	9c 0d       	add	r25, r12
        if(response == OUT_OF_BORDER)
 9f8:	81 30       	cpi	r24, 0x01	; 1
 9fa:	41 f0       	breq	.+16     	; 0xa0c <LcdBars+0x66>
 9fc:	81 2f       	mov	r24, r17
 9fe:	19 2f       	mov	r17, r25
{
	byte b;
	byte tmpIdx = 0;
    byte response;

	for ( b = 0;  b < numbBars ; b++ )
 a00:	ca 15       	cp	r28, r10
 a02:	38 f3       	brcs	.-50     	; 0x9d2 <LcdBars+0x2c>
        if(response == OUT_OF_BORDER)
            return response;
	}

	/* Set update flag to be true */
	UpdateLcd = TRUE;
 a04:	81 e0       	ldi	r24, 0x01	; 1
 a06:	80 93 5e 02 	sts	0x025E, r24
 a0a:	80 e0       	ldi	r24, 0x00	; 0
    return OK;

}
 a0c:	df 91       	pop	r29
 a0e:	cf 91       	pop	r28
 a10:	1f 91       	pop	r17
 a12:	0f 91       	pop	r16
 a14:	ff 90       	pop	r15
 a16:	ef 90       	pop	r14
 a18:	df 90       	pop	r13
 a1a:	cf 90       	pop	r12
 a1c:	bf 90       	pop	r11
 a1e:	af 90       	pop	r10
 a20:	08 95       	ret

00000a22 <LcdRect>:
 *				   y2   -> absolute second y axis coordinate
 *				   mode -> Off, On or Xor. See enum in pcd8544.h.
 * Return value :  see return value on pcd8544.h.
 */
byte LcdRect ( byte x1, byte x2, byte y1, byte y2, LcdPixelMode mode )
{
 a22:	cf 92       	push	r12
 a24:	df 92       	push	r13
 a26:	ef 92       	push	r14
 a28:	ff 92       	push	r15
 a2a:	0f 93       	push	r16
 a2c:	1f 93       	push	r17
 a2e:	d8 2e       	mov	r13, r24
 a30:	e6 2e       	mov	r14, r22
 a32:	f2 2e       	mov	r15, r18
 a34:	c0 2e       	mov	r12, r16
	byte tmpIdxX,tmpIdxY;
    byte response;

	/* Checking border */
	if ( ( x1 > LCD_X_RES ) ||  ( x2 > LCD_X_RES ) || ( y1 > LCD_Y_RES ) || ( y2 > LCD_Y_RES ) )
 a36:	84 e5       	ldi	r24, 0x54	; 84
 a38:	8d 15       	cp	r24, r13
 a3a:	f8 f0       	brcs	.+62     	; 0xa7a <LcdRect+0x58>
 a3c:	86 17       	cp	r24, r22
 a3e:	e8 f0       	brcs	.+58     	; 0xa7a <LcdRect+0x58>
 a40:	41 33       	cpi	r20, 0x31	; 49
 a42:	d8 f4       	brcc	.+54     	; 0xa7a <LcdRect+0x58>
 a44:	80 e3       	ldi	r24, 0x30	; 48
 a46:	82 17       	cp	r24, r18
 a48:	c0 f0       	brcs	.+48     	; 0xa7a <LcdRect+0x58>
		/* If out of border then return */
		return OUT_OF_BORDER;

	if ( ( x2 > x1 ) && ( y2 > y1 ) )
 a4a:	d6 16       	cp	r13, r22
 a4c:	c0 f4       	brcc	.+48     	; 0xa7e <LcdRect+0x5c>
 a4e:	42 17       	cp	r20, r18
 a50:	b0 f4       	brcc	.+44     	; 0xa7e <LcdRect+0x5c>
 a52:	04 2f       	mov	r16, r20
 a54:	0a c0       	rjmp	.+20     	; 0xa6a <LcdRect+0x48>
		{
			/* Draw line horizontally */
			for ( tmpIdxX = x1; tmpIdxX < x2; tmpIdxX++ )
            {
				/* Draw a pixel */
				response = LcdPixel( tmpIdxX, tmpIdxY, mode );
 a56:	81 2f       	mov	r24, r17
 a58:	60 2f       	mov	r22, r16
 a5a:	4c 2d       	mov	r20, r12
 a5c:	84 de       	rcall	.-760    	; 0x766 <LcdPixel>
                if(response)
 a5e:	88 23       	and	r24, r24
 a60:	79 f4       	brne	.+30     	; 0xa80 <LcdRect+0x5e>
	if ( ( x2 > x1 ) && ( y2 > y1 ) )
	{
		for ( tmpIdxY = y1; tmpIdxY < y2; tmpIdxY++ )
		{
			/* Draw line horizontally */
			for ( tmpIdxX = x1; tmpIdxX < x2; tmpIdxX++ )
 a62:	1f 5f       	subi	r17, 0xFF	; 255
 a64:	1e 15       	cp	r17, r14
 a66:	b8 f3       	brcs	.-18     	; 0xa56 <LcdRect+0x34>
		/* If out of border then return */
		return OUT_OF_BORDER;

	if ( ( x2 > x1 ) && ( y2 > y1 ) )
	{
		for ( tmpIdxY = y1; tmpIdxY < y2; tmpIdxY++ )
 a68:	0f 5f       	subi	r16, 0xFF	; 255
 a6a:	0f 15       	cp	r16, r15
 a6c:	10 f4       	brcc	.+4      	; 0xa72 <LcdRect+0x50>
 a6e:	1d 2d       	mov	r17, r13
 a70:	f9 cf       	rjmp	.-14     	; 0xa64 <LcdRect+0x42>
                    return response;
            }
		}

		/* Set update flag to be true */
		UpdateLcd = TRUE;
 a72:	81 e0       	ldi	r24, 0x01	; 1
 a74:	80 93 5e 02 	sts	0x025E, r24
 a78:	02 c0       	rjmp	.+4      	; 0xa7e <LcdRect+0x5c>
 a7a:	81 e0       	ldi	r24, 0x01	; 1
 a7c:	01 c0       	rjmp	.+2      	; 0xa80 <LcdRect+0x5e>
 a7e:	80 e0       	ldi	r24, 0x00	; 0
	}
    return OK;
}
 a80:	1f 91       	pop	r17
 a82:	0f 91       	pop	r16
 a84:	ff 90       	pop	r15
 a86:	ef 90       	pop	r14
 a88:	df 90       	pop	r13
 a8a:	cf 90       	pop	r12
 a8c:	08 95       	ret

00000a8e <LcdUpdate>:
 */
void LcdUpdate ( void )
{
    int i;

    if ( LoWaterMark < 0 )
 a8e:	80 91 5a 02 	lds	r24, 0x025A
 a92:	90 91 5b 02 	lds	r25, 0x025B
 a96:	97 ff       	sbrs	r25, 7
 a98:	05 c0       	rjmp	.+10     	; 0xaa4 <LcdUpdate+0x16>
        LoWaterMark = 0;
 a9a:	10 92 5b 02 	sts	0x025B, r1
 a9e:	10 92 5a 02 	sts	0x025A, r1
 aa2:	09 c0       	rjmp	.+18     	; 0xab6 <LcdUpdate+0x28>
    else if ( LoWaterMark >= LCD_CACHE_SIZE )
 aa4:	88 5f       	subi	r24, 0xF8	; 248
 aa6:	91 40       	sbci	r25, 0x01	; 1
 aa8:	34 f0       	brlt	.+12     	; 0xab6 <LcdUpdate+0x28>
        LoWaterMark = LCD_CACHE_SIZE - 1;
 aaa:	87 ef       	ldi	r24, 0xF7	; 247
 aac:	91 e0       	ldi	r25, 0x01	; 1
 aae:	90 93 5b 02 	sts	0x025B, r25
 ab2:	80 93 5a 02 	sts	0x025A, r24

    if ( HiWaterMark < 0 )
 ab6:	80 91 5c 02 	lds	r24, 0x025C
 aba:	90 91 5d 02 	lds	r25, 0x025D
 abe:	97 ff       	sbrs	r25, 7
 ac0:	05 c0       	rjmp	.+10     	; 0xacc <LcdUpdate+0x3e>
        HiWaterMark = 0;
 ac2:	10 92 5d 02 	sts	0x025D, r1
 ac6:	10 92 5c 02 	sts	0x025C, r1
 aca:	09 c0       	rjmp	.+18     	; 0xade <LcdUpdate+0x50>
    else if ( HiWaterMark >= LCD_CACHE_SIZE )
 acc:	88 5f       	subi	r24, 0xF8	; 248
 ace:	91 40       	sbci	r25, 0x01	; 1
 ad0:	34 f0       	brlt	.+12     	; 0xade <LcdUpdate+0x50>
        HiWaterMark = LCD_CACHE_SIZE - 1;
 ad2:	87 ef       	ldi	r24, 0xF7	; 247
 ad4:	91 e0       	ldi	r25, 0x01	; 1
 ad6:	90 93 5d 02 	sts	0x025D, r25
 ada:	80 93 5c 02 	sts	0x025C, r24

    /*  Set base address according to LoWaterMark. */
    LcdSend( 0x80 | ( LoWaterMark % LCD_X_RES ), LCD_CMD );
 ade:	20 91 5a 02 	lds	r18, 0x025A
 ae2:	30 91 5b 02 	lds	r19, 0x025B
 ae6:	c9 01       	movw	r24, r18
 ae8:	64 e5       	ldi	r22, 0x54	; 84
 aea:	70 e0       	ldi	r23, 0x00	; 0
 aec:	a9 d0       	rcall	.+338    	; 0xc40 <__divmodhi4>
 aee:	80 68       	ori	r24, 0x80	; 128
 * Return value :  None.
 */
static void LcdSend ( byte data, LcdCmdData cd )
{
    /*  Enable display controller (active low). */
    LCD_PORT &= ~( _BV( LCD_CE_PIN ) );
 af0:	c2 98       	cbi	0x18, 2	; 24
    {
        LCD_PORT |= _BV( LCD_DC_PIN );
    }
    else
    {
        LCD_PORT &= ~( _BV( LCD_DC_PIN ) );
 af2:	c0 98       	cbi	0x18, 0	; 24
    }

    /*  Send data to display controller. */
    SPDR = data;
 af4:	8f b9       	out	0x0f, r24	; 15

    /*  Wait until Tx register empty. */
    while ( (SPSR & 0x80) != 0x80 );
 af6:	77 9b       	sbis	0x0e, 7	; 14
 af8:	fe cf       	rjmp	.-4      	; 0xaf6 <LcdUpdate+0x68>


    /* Disable display controller. */
    LCD_PORT |= _BV( LCD_CE_PIN );
 afa:	c2 9a       	sbi	0x18, 2	; 24
    else if ( HiWaterMark >= LCD_CACHE_SIZE )
        HiWaterMark = LCD_CACHE_SIZE - 1;

    /*  Set base address according to LoWaterMark. */
    LcdSend( 0x80 | ( LoWaterMark % LCD_X_RES ), LCD_CMD );
    LcdSend( 0x40 | ( LoWaterMark / LCD_X_RES ), LCD_CMD );
 afc:	c9 01       	movw	r24, r18
 afe:	64 e5       	ldi	r22, 0x54	; 84
 b00:	70 e0       	ldi	r23, 0x00	; 0
 b02:	9e d0       	rcall	.+316    	; 0xc40 <__divmodhi4>
 b04:	60 64       	ori	r22, 0x40	; 64
 * Return value :  None.
 */
static void LcdSend ( byte data, LcdCmdData cd )
{
    /*  Enable display controller (active low). */
    LCD_PORT &= ~( _BV( LCD_CE_PIN ) );
 b06:	c2 98       	cbi	0x18, 2	; 24
    {
        LCD_PORT |= _BV( LCD_DC_PIN );
    }
    else
    {
        LCD_PORT &= ~( _BV( LCD_DC_PIN ) );
 b08:	c0 98       	cbi	0x18, 0	; 24
    }

    /*  Send data to display controller. */
    SPDR = data;
 b0a:	6f b9       	out	0x0f, r22	; 15

    /*  Wait until Tx register empty. */
    while ( (SPSR & 0x80) != 0x80 );
 b0c:	77 9b       	sbis	0x0e, 7	; 14
 b0e:	fe cf       	rjmp	.-4      	; 0xb0c <LcdUpdate+0x7e>


    /* Disable display controller. */
    LCD_PORT |= _BV( LCD_CE_PIN );
 b10:	c2 9a       	sbi	0x18, 2	; 24
    /*  Set base address according to LoWaterMark. */
    LcdSend( 0x80 | ( LoWaterMark % LCD_X_RES ), LCD_CMD );
    LcdSend( 0x40 | ( LoWaterMark / LCD_X_RES ), LCD_CMD );

    /*  Serialize the display buffer. */
    for ( i = LoWaterMark; i <= HiWaterMark; i++ )
 b12:	40 91 5c 02 	lds	r20, 0x025C
 b16:	50 91 5d 02 	lds	r21, 0x025D
 b1a:	f9 01       	movw	r30, r18
 b1c:	e0 5a       	subi	r30, 0xA0	; 160
 b1e:	ff 4f       	sbci	r31, 0xFF	; 255
 b20:	0a c0       	rjmp	.+20     	; 0xb36 <LcdUpdate+0xa8>
    {
        LcdSend( LcdCache[ i ], LCD_DATA );
 b22:	80 81       	ld	r24, Z
 * Return value :  None.
 */
static void LcdSend ( byte data, LcdCmdData cd )
{
    /*  Enable display controller (active low). */
    LCD_PORT &= ~( _BV( LCD_CE_PIN ) );
 b24:	c2 98       	cbi	0x18, 2	; 24

    if ( cd == LCD_DATA )
    {
        LCD_PORT |= _BV( LCD_DC_PIN );
 b26:	c0 9a       	sbi	0x18, 0	; 24
    {
        LCD_PORT &= ~( _BV( LCD_DC_PIN ) );
    }

    /*  Send data to display controller. */
    SPDR = data;
 b28:	8f b9       	out	0x0f, r24	; 15

    /*  Wait until Tx register empty. */
    while ( (SPSR & 0x80) != 0x80 );
 b2a:	77 9b       	sbis	0x0e, 7	; 14
 b2c:	fe cf       	rjmp	.-4      	; 0xb2a <LcdUpdate+0x9c>


    /* Disable display controller. */
    LCD_PORT |= _BV( LCD_CE_PIN );
 b2e:	c2 9a       	sbi	0x18, 2	; 24
    /*  Set base address according to LoWaterMark. */
    LcdSend( 0x80 | ( LoWaterMark % LCD_X_RES ), LCD_CMD );
    LcdSend( 0x40 | ( LoWaterMark / LCD_X_RES ), LCD_CMD );

    /*  Serialize the display buffer. */
    for ( i = LoWaterMark; i <= HiWaterMark; i++ )
 b30:	2f 5f       	subi	r18, 0xFF	; 255
 b32:	3f 4f       	sbci	r19, 0xFF	; 255
 b34:	31 96       	adiw	r30, 0x01	; 1
 b36:	42 17       	cp	r20, r18
 b38:	53 07       	cpc	r21, r19
 b3a:	9c f7       	brge	.-26     	; 0xb22 <LcdUpdate+0x94>
    {
        LcdSend( LcdCache[ i ], LCD_DATA );
    }

    /*  Reset watermark pointers. */
    LoWaterMark = LCD_CACHE_SIZE - 1;
 b3c:	87 ef       	ldi	r24, 0xF7	; 247
 b3e:	91 e0       	ldi	r25, 0x01	; 1
 b40:	90 93 5b 02 	sts	0x025B, r25
 b44:	80 93 5a 02 	sts	0x025A, r24
    HiWaterMark = 0;
 b48:	10 92 5d 02 	sts	0x025D, r1
 b4c:	10 92 5c 02 	sts	0x025C, r1

    /* Set update flag to be true */
	UpdateLcd = FALSE;
 b50:	10 92 5e 02 	sts	0x025E, r1
}
 b54:	08 95       	ret

00000b56 <LcdImage>:
 * Argument(s)  :  Address of image in hexes
 * Return value :  None.
 * Example      :  LcdImage(&sample_image_declared_as_array);
 */
void LcdImage ( const byte *imageData )
{
 b56:	bc 01       	movw	r22, r24
//    {
//		/* Copy data from pointer to cache buffer */
//        LcdCache[LcdCacheIdx] = pgm_read_byte( imageData++ );
//    }
	/* optimized by Jakub Lasinski, version 0.2.6, March 14, 2009 */
    memcpy_P(LcdCache,imageData,LCD_CACHE_SIZE);	//Same as aboeve - 6 bytes less and faster instruction
 b58:	80 e6       	ldi	r24, 0x60	; 96
 b5a:	90 e0       	ldi	r25, 0x00	; 0
 b5c:	48 ef       	ldi	r20, 0xF8	; 248
 b5e:	51 e0       	ldi	r21, 0x01	; 1
 b60:	66 d0       	rcall	.+204    	; 0xc2e <memcpy_P>
	/* Reset watermark pointers to be full */
    LoWaterMark = 0;
 b62:	10 92 5b 02 	sts	0x025B, r1
 b66:	10 92 5a 02 	sts	0x025A, r1
    HiWaterMark = LCD_CACHE_SIZE - 1;
 b6a:	87 ef       	ldi	r24, 0xF7	; 247
 b6c:	91 e0       	ldi	r25, 0x01	; 1
 b6e:	90 93 5d 02 	sts	0x025D, r25
 b72:	80 93 5c 02 	sts	0x025C, r24

	/* Set update flag to be true */
    UpdateLcd = TRUE;
 b76:	81 e0       	ldi	r24, 0x01	; 1
 b78:	80 93 5e 02 	sts	0x025E, r24
}
 b7c:	08 95       	ret

00000b7e <LcdClear>:
//    /* Set 0x00 to all LcdCache's contents */
//    for ( i = 0; i < LCD_CACHE_SIZE; i++ )
//    {
//        LcdCache[ i ] = 0x00;
//    }
	memset(LcdCache,0x00,LCD_CACHE_SIZE); //Sugestion - its faster and its 10 bytes less in program mem
 b7e:	88 ef       	ldi	r24, 0xF8	; 248
 b80:	91 e0       	ldi	r25, 0x01	; 1
 b82:	e0 e6       	ldi	r30, 0x60	; 96
 b84:	f0 e0       	ldi	r31, 0x00	; 0
 b86:	df 01       	movw	r26, r30
 b88:	9c 01       	movw	r18, r24
 b8a:	1d 92       	st	X+, r1
 b8c:	21 50       	subi	r18, 0x01	; 1
 b8e:	30 40       	sbci	r19, 0x00	; 0
 b90:	e1 f7       	brne	.-8      	; 0xb8a <LcdClear+0xc>
    /* Reset watermark pointers to full */
    LoWaterMark = 0;
 b92:	10 92 5b 02 	sts	0x025B, r1
 b96:	10 92 5a 02 	sts	0x025A, r1
    HiWaterMark = LCD_CACHE_SIZE - 1;
 b9a:	87 ef       	ldi	r24, 0xF7	; 247
 b9c:	91 e0       	ldi	r25, 0x01	; 1
 b9e:	90 93 5d 02 	sts	0x025D, r25
 ba2:	80 93 5c 02 	sts	0x025C, r24

    /* Set update flag to be true */
    UpdateLcd = TRUE;
 ba6:	81 e0       	ldi	r24, 0x01	; 1
 ba8:	80 93 5e 02 	sts	0x025E, r24
}
 bac:	08 95       	ret

00000bae <LcdInit>:
 * Return value :  None.
 */
void LcdInit ( void )
{
    /* Pull-up on reset pin. */
    LCD_PORT |= _BV ( LCD_RST_PIN );
 bae:	c4 9a       	sbi	0x18, 4	; 24

    /* Set output bits on LCD Port. */
    LCD_DDR |= _BV( LCD_RST_PIN ) | _BV( LCD_DC_PIN ) | _BV( LCD_CE_PIN ) | _BV( SPI_MOSI_PIN ) | _BV( SPI_CLK_PIN );
 bb0:	87 b3       	in	r24, 0x17	; 23
 bb2:	8d 63       	ori	r24, 0x3D	; 61
 bb4:	87 bb       	out	0x17, r24	; 23

    Delay();

    /* Toggle display reset pin. */
    LCD_PORT &= ~( _BV( LCD_RST_PIN ) );
 bb6:	c4 98       	cbi	0x18, 4	; 24
    Delay();
    LCD_PORT |= _BV ( LCD_RST_PIN );
 bb8:	c4 9a       	sbi	0x18, 4	; 24

    /* Enable SPI port:
    * No interrupt, MSBit first, Master mode, CPOL->0, CPHA->0, Clk/4
    */
    SPCR = 0x50;
 bba:	80 e5       	ldi	r24, 0x50	; 80
 bbc:	8d b9       	out	0x0d, r24	; 13

    /* Disable LCD controller */
    LCD_PORT |= _BV( LCD_CE_PIN );
 bbe:	c2 9a       	sbi	0x18, 2	; 24
 * Return value :  None.
 */
static void LcdSend ( byte data, LcdCmdData cd )
{
    /*  Enable display controller (active low). */
    LCD_PORT &= ~( _BV( LCD_CE_PIN ) );
 bc0:	c2 98       	cbi	0x18, 2	; 24
    {
        LCD_PORT |= _BV( LCD_DC_PIN );
    }
    else
    {
        LCD_PORT &= ~( _BV( LCD_DC_PIN ) );
 bc2:	c0 98       	cbi	0x18, 0	; 24
    }

    /*  Send data to display controller. */
    SPDR = data;
 bc4:	81 e2       	ldi	r24, 0x21	; 33
 bc6:	8f b9       	out	0x0f, r24	; 15

    /*  Wait until Tx register empty. */
    while ( (SPSR & 0x80) != 0x80 );
 bc8:	77 9b       	sbis	0x0e, 7	; 14
 bca:	fe cf       	rjmp	.-4      	; 0xbc8 <LcdInit+0x1a>


    /* Disable display controller. */
    LCD_PORT |= _BV( LCD_CE_PIN );
 bcc:	c2 9a       	sbi	0x18, 2	; 24
 * Return value :  None.
 */
static void LcdSend ( byte data, LcdCmdData cd )
{
    /*  Enable display controller (active low). */
    LCD_PORT &= ~( _BV( LCD_CE_PIN ) );
 bce:	c2 98       	cbi	0x18, 2	; 24
    {
        LCD_PORT |= _BV( LCD_DC_PIN );
    }
    else
    {
        LCD_PORT &= ~( _BV( LCD_DC_PIN ) );
 bd0:	c0 98       	cbi	0x18, 0	; 24
    }

    /*  Send data to display controller. */
    SPDR = data;
 bd2:	88 ec       	ldi	r24, 0xC8	; 200
 bd4:	8f b9       	out	0x0f, r24	; 15

    /*  Wait until Tx register empty. */
    while ( (SPSR & 0x80) != 0x80 );
 bd6:	77 9b       	sbis	0x0e, 7	; 14
 bd8:	fe cf       	rjmp	.-4      	; 0xbd6 <LcdInit+0x28>


    /* Disable display controller. */
    LCD_PORT |= _BV( LCD_CE_PIN );
 bda:	c2 9a       	sbi	0x18, 2	; 24
 * Return value :  None.
 */
static void LcdSend ( byte data, LcdCmdData cd )
{
    /*  Enable display controller (active low). */
    LCD_PORT &= ~( _BV( LCD_CE_PIN ) );
 bdc:	c2 98       	cbi	0x18, 2	; 24
    {
        LCD_PORT |= _BV( LCD_DC_PIN );
    }
    else
    {
        LCD_PORT &= ~( _BV( LCD_DC_PIN ) );
 bde:	c0 98       	cbi	0x18, 0	; 24
    }

    /*  Send data to display controller. */
    SPDR = data;
 be0:	86 e0       	ldi	r24, 0x06	; 6
 be2:	8f b9       	out	0x0f, r24	; 15

    /*  Wait until Tx register empty. */
    while ( (SPSR & 0x80) != 0x80 );
 be4:	77 9b       	sbis	0x0e, 7	; 14
 be6:	fe cf       	rjmp	.-4      	; 0xbe4 <LcdInit+0x36>


    /* Disable display controller. */
    LCD_PORT |= _BV( LCD_CE_PIN );
 be8:	c2 9a       	sbi	0x18, 2	; 24
 * Return value :  None.
 */
static void LcdSend ( byte data, LcdCmdData cd )
{
    /*  Enable display controller (active low). */
    LCD_PORT &= ~( _BV( LCD_CE_PIN ) );
 bea:	c2 98       	cbi	0x18, 2	; 24
    {
        LCD_PORT |= _BV( LCD_DC_PIN );
    }
    else
    {
        LCD_PORT &= ~( _BV( LCD_DC_PIN ) );
 bec:	c0 98       	cbi	0x18, 0	; 24
    }

    /*  Send data to display controller. */
    SPDR = data;
 bee:	83 e1       	ldi	r24, 0x13	; 19
 bf0:	8f b9       	out	0x0f, r24	; 15

    /*  Wait until Tx register empty. */
    while ( (SPSR & 0x80) != 0x80 );
 bf2:	77 9b       	sbis	0x0e, 7	; 14
 bf4:	fe cf       	rjmp	.-4      	; 0xbf2 <LcdInit+0x44>


    /* Disable display controller. */
    LCD_PORT |= _BV( LCD_CE_PIN );
 bf6:	c2 9a       	sbi	0x18, 2	; 24
 * Return value :  None.
 */
static void LcdSend ( byte data, LcdCmdData cd )
{
    /*  Enable display controller (active low). */
    LCD_PORT &= ~( _BV( LCD_CE_PIN ) );
 bf8:	c2 98       	cbi	0x18, 2	; 24
    {
        LCD_PORT |= _BV( LCD_DC_PIN );
    }
    else
    {
        LCD_PORT &= ~( _BV( LCD_DC_PIN ) );
 bfa:	c0 98       	cbi	0x18, 0	; 24
    }

    /*  Send data to display controller. */
    SPDR = data;
 bfc:	80 e2       	ldi	r24, 0x20	; 32
 bfe:	8f b9       	out	0x0f, r24	; 15

    /*  Wait until Tx register empty. */
    while ( (SPSR & 0x80) != 0x80 );
 c00:	77 9b       	sbis	0x0e, 7	; 14
 c02:	fe cf       	rjmp	.-4      	; 0xc00 <LcdInit+0x52>


    /* Disable display controller. */
    LCD_PORT |= _BV( LCD_CE_PIN );
 c04:	c2 9a       	sbi	0x18, 2	; 24
 * Return value :  None.
 */
static void LcdSend ( byte data, LcdCmdData cd )
{
    /*  Enable display controller (active low). */
    LCD_PORT &= ~( _BV( LCD_CE_PIN ) );
 c06:	c2 98       	cbi	0x18, 2	; 24
    {
        LCD_PORT |= _BV( LCD_DC_PIN );
    }
    else
    {
        LCD_PORT &= ~( _BV( LCD_DC_PIN ) );
 c08:	c0 98       	cbi	0x18, 0	; 24
    }

    /*  Send data to display controller. */
    SPDR = data;
 c0a:	8c e0       	ldi	r24, 0x0C	; 12
 c0c:	8f b9       	out	0x0f, r24	; 15

    /*  Wait until Tx register empty. */
    while ( (SPSR & 0x80) != 0x80 );
 c0e:	77 9b       	sbis	0x0e, 7	; 14
 c10:	fe cf       	rjmp	.-4      	; 0xc0e <LcdInit+0x60>


    /* Disable display controller. */
    LCD_PORT |= _BV( LCD_CE_PIN );
 c12:	c2 9a       	sbi	0x18, 2	; 24
    LcdSend( 0x13, LCD_CMD ); /* LCD bias mode 1:48. */
    LcdSend( 0x20, LCD_CMD ); /* LCD Standard Commands,Horizontal addressing mode */
    LcdSend( 0x0C, LCD_CMD ); /* LCD in normal mode. */

    /* Reset watermark pointers to empty */
    LoWaterMark = LCD_CACHE_SIZE;
 c14:	88 ef       	ldi	r24, 0xF8	; 248
 c16:	91 e0       	ldi	r25, 0x01	; 1
 c18:	90 93 5b 02 	sts	0x025B, r25
 c1c:	80 93 5a 02 	sts	0x025A, r24
    HiWaterMark = 0;
 c20:	10 92 5d 02 	sts	0x025D, r1
 c24:	10 92 5c 02 	sts	0x025C, r1

    /* Clear display on first time use */
    LcdClear();
 c28:	aa df       	rcall	.-172    	; 0xb7e <LcdClear>
    LcdUpdate();
 c2a:	31 df       	rcall	.-414    	; 0xa8e <LcdUpdate>
}
 c2c:	08 95       	ret

00000c2e <memcpy_P>:
 c2e:	fb 01       	movw	r30, r22
 c30:	dc 01       	movw	r26, r24
 c32:	02 c0       	rjmp	.+4      	; 0xc38 <memcpy_P+0xa>
 c34:	05 90       	lpm	r0, Z+
 c36:	0d 92       	st	X+, r0
 c38:	41 50       	subi	r20, 0x01	; 1
 c3a:	50 40       	sbci	r21, 0x00	; 0
 c3c:	d8 f7       	brcc	.-10     	; 0xc34 <memcpy_P+0x6>
 c3e:	08 95       	ret

00000c40 <__divmodhi4>:
 c40:	97 fb       	bst	r25, 7
 c42:	09 2e       	mov	r0, r25
 c44:	07 26       	eor	r0, r23
 c46:	0a d0       	rcall	.+20     	; 0xc5c <__divmodhi4_neg1>
 c48:	77 fd       	sbrc	r23, 7
 c4a:	04 d0       	rcall	.+8      	; 0xc54 <__divmodhi4_neg2>
 c4c:	0c d0       	rcall	.+24     	; 0xc66 <__udivmodhi4>
 c4e:	06 d0       	rcall	.+12     	; 0xc5c <__divmodhi4_neg1>
 c50:	00 20       	and	r0, r0
 c52:	1a f4       	brpl	.+6      	; 0xc5a <__divmodhi4_exit>

00000c54 <__divmodhi4_neg2>:
 c54:	70 95       	com	r23
 c56:	61 95       	neg	r22
 c58:	7f 4f       	sbci	r23, 0xFF	; 255

00000c5a <__divmodhi4_exit>:
 c5a:	08 95       	ret

00000c5c <__divmodhi4_neg1>:
 c5c:	f6 f7       	brtc	.-4      	; 0xc5a <__divmodhi4_exit>
 c5e:	90 95       	com	r25
 c60:	81 95       	neg	r24
 c62:	9f 4f       	sbci	r25, 0xFF	; 255
 c64:	08 95       	ret

00000c66 <__udivmodhi4>:
 c66:	aa 1b       	sub	r26, r26
 c68:	bb 1b       	sub	r27, r27
 c6a:	51 e1       	ldi	r21, 0x11	; 17
 c6c:	07 c0       	rjmp	.+14     	; 0xc7c <__udivmodhi4_ep>

00000c6e <__udivmodhi4_loop>:
 c6e:	aa 1f       	adc	r26, r26
 c70:	bb 1f       	adc	r27, r27
 c72:	a6 17       	cp	r26, r22
 c74:	b7 07       	cpc	r27, r23
 c76:	10 f0       	brcs	.+4      	; 0xc7c <__udivmodhi4_ep>
 c78:	a6 1b       	sub	r26, r22
 c7a:	b7 0b       	sbc	r27, r23

00000c7c <__udivmodhi4_ep>:
 c7c:	88 1f       	adc	r24, r24
 c7e:	99 1f       	adc	r25, r25
 c80:	5a 95       	dec	r21
 c82:	a9 f7       	brne	.-22     	; 0xc6e <__udivmodhi4_loop>
 c84:	80 95       	com	r24
 c86:	90 95       	com	r25
 c88:	bc 01       	movw	r22, r24
 c8a:	cd 01       	movw	r24, r26
 c8c:	08 95       	ret

00000c8e <_exit>:
 c8e:	f8 94       	cli

00000c90 <__stop_program>:
 c90:	ff cf       	rjmp	.-2      	; 0xc90 <__stop_program>
